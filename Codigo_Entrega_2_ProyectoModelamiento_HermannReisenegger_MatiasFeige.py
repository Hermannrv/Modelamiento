# -*- coding: utf-8 -*-
"""Entrega 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12gcx1liyD7p58MDFp11W2yGjRYXFTpQo
"""

#!pip install xlsxwriter
#!pip install gurobipy
#!pip install xlrd


# -*- coding: utf-8 -*-

import xlsxwriter as xl
import gurobipy as gp
from gurobipy import GRB,quicksum
from itertools import product
import xlrd
import time as tiempo
from rw_excel import sets_list, param_dicc, wr_var

def cosecha(dir_result,T,K,I,V,S,ap,eh,sh,vs,lah,lrh,lbh,mop,d,p,ps,ch,clabor,cap,ct,Theta):

################################################################# IMPLEMENTAR MODELO DE COSECHA EN GUROBI #######################################################################  
  #Se plantea el modelo a Optimizar
  modelo_grupo2 = gp.Model("Proyecto_Grupo_2")
  modelo_grupo2.modelSense = GRB.MAXIMIZE

  # Variables independientes del modelo (Sub indices)
  X_t_i_k_v_s = modelo_grupo2.addVars({(t,i,k,v,s) for t in T for i in I for k in K for v in V for s in S}, vtype = GRB.CONTINUOUS) 	# area cosechada
  QH_t_i_k_s = modelo_grupo2.addVars({(t,i,k,s) for t in T for i in I for k in K for s in S}, vtype = GRB.CONTINUOUS)               	# cajas cosechadas
  NTF_t_s = modelo_grupo2.addVars({(t,s) for t in T for s in S}, vtype = GRB.INTEGER)												    # numero de camiones necesarios para enviar el total de lo cosechado al centro
  QS_t_i_k_s = modelo_grupo2.addVars({(t,i,k,s) for t in T for i in I for k in K for s in S}, vtype = GRB.CONTINUOUS)	    			# cajas descartadas
  OPL_t_i_s = modelo_grupo2.addVars({(t,i,s) for t in T for i in I for s in S}, vtype = GRB.CONTINUOUS)								    # horas de trabajo contratada
  HS_t_i_s = modelo_grupo2.addVars({(t,i,s) for t in T for i in I for s in S}, vtype = GRB.CONTINUOUS)							        # cosecha realizada (cantidad, volumen?)
  YQ_t_i_k_s = modelo_grupo2.addVars({(t,i,k,s) for t in T for i in I for k in K for s in S}, lb = 0, ub = 1, vtype = GRB.BINARY)	    # si se cosecha o no
  CT_carga_s = modelo_grupo2.addVars({(s) for s in S}, vtype = GRB.CONTINUOUS)					                                        # costo de carga la carga transportada de producto
  
  # Función Objetivo
  modelo_grupo2.setObjective(quicksum([QH_t_i_k_s[t,i,k,s] * p[k,t] * Theta[s] for k in K for i in I for t in T for s in S]) + quicksum([QS_t_i_k_s[t,i,k,s] * ps[k,t] * Theta[s] for k in K for i in I for t in T for s in S]) - quicksum([(lah[i,t] + OPL_t_i_s[t,i,s])*Theta[s] for i in I for t in T for s in S])*clabor - quicksum([ch[k] * QH_t_i_k_s[t,i,k,s] * Theta[s] for k in K for i in I for t in T for s in S]) - quicksum([CT_carga_s[s] * Theta[s] for s in S]))
  

  #Restricciones

  t=1
  i=1
  k=1
  r=1
  v=1
  s=1
  
  #1: costo de la carga a ser transportada
  for s in S:
      modelo_grupo2.addConstr(CT_carga_s[s] == quicksum([cap*YQ_t_i_k_s[t,i,k,s] * ct[i] for k in K for i in I for t in T]), f"Restricción 01_{s}")

  #2: la cantidad de cajas cosechadas depende de el area de cosecha acorde al patron y la cosecha esperada.
  
  for k in K:
      for i in I:
          for t in T:
              for s in S:
                  expr = quicksum([X_t_i_k_v_s[t,i,k,v,s] * eh[t,i,k,v,s] for v in V])
                  modelo_grupo2.addConstr((QH_t_i_k_s[t,i,k,s] == expr), f"Restricción 02_{t}_{i}_{k}_{s}")
  
      



  #3: limita la cantidad de cosecha a la capacidad del camion:
  
  for k in K:
    for i in I:
        for t in T:
            for s in S:
                expr = QH_t_i_k_s[t,i,k,s]
                modelo_grupo2.addConstr(expr <= cap, f"Restricción 03_{t}_{i}_{k}_{s}")

  #4: la cantidad de producto descartado depende del area de la cosecha acorde al patron, la cosecha esperada y la cantidad descartada estimada
  
  for k in K:
    for i in I:
        for t in T:
            for s in S:
                expr = quicksum([X_t_i_k_v_s[t,i,k,v,s] * eh[t,i,k,v,s] * vs[t,k] for v in V])
                modelo_grupo2.addConstr(QS_t_i_k_s[t,i,k,s] == expr, f"Restricción 04_{t}_{i}_{k}_{s}")

  #5: limita la cantidad cosechada a la cantidad de mano de obra disponible

  for i in I:
    for t in T:
        for s in S:
            expr1 = quicksum([QH_t_i_k_s[t,i,k,s] * lrh[i,k] for k in K])
            expr2 = quicksum([sh[t,v] * X_t_i_k_v_s[t,i,k,v,s] * lbh[i,k,s] for v in V for k in K])
            expr = expr1 + expr2
            modelo_grupo2.addConstr(expr <= lah[i,t] + OPL_t_i_s[t,i,s], f"Restricción 05_{t}_{i}_{s}")

  #6: la cantidad enviada al destino debe al menos ser la minima cantidad demandada
   
  for k in K:
    for t in T:
        for s in S:
            expr = quicksum([QH_t_i_k_s[t,i,k,s] for i in I])
            modelo_grupo2.addConstr(expr >= d[k,t], f"Restricción 06_{t}_{k}_{s}")

  #7: limita el área de la cosecha por patron al total del area plantada
  

  
  for k in K:
    for i in I:
        for s in S:
            expr = quicksum([X_t_i_k_v_s[t,i,k,v,s] for t in T for v in V])
            modelo_grupo2.addConstr(expr <= ap[i,k], f'Restricción 07_{i}_{k}')

  #8: la cantidad de mano de obra extra es limitada al maximo de horas de trabajo por dia
  
  for i in I:
      for t in T:
          for s in S:
              expr = OPL_t_i_s[t,i,s]
              modelo_grupo2.addConstr(expr <= mop, f'Restricción 08_{t}_{i}_{s}')

  #9: define el numero de camiones necesarios para el transporte del total de la cosecha al centro de empaquetado.
  
  for t in T:
      for s in S:
          expr = quicksum([QH_t_i_k_s[t,i,k,s] / cap for k in K for i in I])
          modelo_grupo2.addConstr(expr <= NTF_t_s[t,s], f'Restricción 09_{t}_{s}')

  #10: indica la cantidad cosechada
  
  for i in I:
    for t in T:
        for s in S:
            expr = quicksum([QH_t_i_k_s[t,i,k,s] for k in K])
            modelo_grupo2.addConstr(expr == HS_t_i_s[t,i,s], f'Restricción 10_{t}_{i}_{s}')

  #11: indica la cantidad cosechada por huerto
 
  for i in I:
    for t in T:
        for s in S:
            expr = quicksum([YQ_t_i_k_s[t,i,k,s] * cap for k in K])
            modelo_grupo2.addConstr(expr >= HS_t_i_s[t,i,s], f'Restricción 11_{t}_{i}_{s}')
  
  #12: naturaleza de las Variables: No Negatividad
  
  for t in T:
      for i in I:
          for k in K:
              for v in V:
                  for s in S:
                      modelo_grupo2.addConstr(((X_t_i_k_v_s[t,i,k,v,s] >= 0)), 'Restricción 12_a_{t}_{i}_{k}_{v}_{s}')
                      modelo_grupo2.addConstr(((QH_t_i_k_s[t,i,k,s] >= 0)),'Restricción 12_b_{t}_{i}_{k}_{s}')
                      modelo_grupo2.addConstr(((QS_t_i_k_s[t,i,k,s] >= 0)),'Restricción 12_c_{t}_{i}_{k}_{s}')
                      modelo_grupo2.addConstr(((OPL_t_i_s[t,i,s] >= 0)),'Restricción 12_d_{t}_{i}_{s}')
                      modelo_grupo2.addConstr(((HS_t_i_s[t,i,s] >= 0)),'Restricción 12_e_{t}_{i}_{s}')
                      modelo_grupo2.addConstr((CT_carga_s[s] >= 0),'Restricción 12_f_{s}')
                      modelo_grupo2.addConstr((NTF_t_s[t,s] >= 0),'Restricción 12_f_{s}')
                      #una que otra variable no fue necesario darle una restricción de naturaleza debido a su definición en el modelo.
                  
  
   

    
################################################################# ESCRITURA DE EXCEL Y RESULTADOS ########################################################################  
  tc1 = tiempo.time()
  modelo_grupo2.setParam("TimeLimit", 30.0)
  modelo_grupo2.Params.LogToConsole=0   #Se utiliza este comando para que gurobi no imprima en consola la información de la optimización

  modelo_grupo2.optimize()
  
  estados = [gp.GRB.LOADED, gp.GRB.INFEASIBLE, gp.GRB.OPTIMAL, gp.GRB.UNBOUNDED, gp.GRB.INF_OR_UNBD, gp.GRB.CUTOFF, gp.GRB.USER_OBJ_LIMIT, gp.GRB.NODE_LIMIT, gp.GRB.ITERATION_LIMIT, gp.GRB.INTERRUPTED, gp.GRB.INTERRUPTED, gp.GRB.TIME_LIMIT, gp.GRB.SOLUTION_LIMIT, gp.GRB.NUMERIC, gp.GRB.SUBOPTIMAL]  
  
  for estado in estados:
    if modelo_grupo2.status == estado:
        print(f"El modelo tiene estado {estado}: {modelo_grupo2.status}")
      
         
  tc2 = tiempo.time()
  tc = tc2 - tc1
  #Tiempo que se demora
  print('Tiempo: ',tc)
  
  #Valor de la funcion objetivo
  print('OBJ: ',modelo_grupo2.objVal)
  
	
  #Escribir resultados variables en excel
  wb = xl.Workbook(dir_result)

  worksheet = wb.add_worksheet('FO')
  r=0
  col=0
  worksheet.write(r, col, 'FO')
  worksheet.write(r+1, col, modelo_grupo2.getObjective().getValue())
  worksheet.write(r, col+1, 'tiempo')
  worksheet.write(r+1, col+1,tc)

  wr_var(wb,'X',X_t_i_k_v_s,('T','I','K','V','S'),T,I,K,V,S)
  wr_var(wb,'QH',QH_t_i_k_s,('T','I','K','S'),T,I,K,S)
  wr_var(wb,'OPL',OPL_t_i_s,('T','I','S'),T,I,S)
  wr_var(wb,'QS',QS_t_i_k_s,('T','I','K','S'),T,I,K,S)
  wr_var(wb,'NTF',NTF_t_s,('T','S'),T,S)
  wr_var(wb,'Y',YQ_t_i_k_s,('T','I','K','S'),T,I,K,S)

  worksheet=wb.add_worksheet('HS')
  r=0
  col=0
  worksheet.write(r, col, 'T')
  worksheet.write(r, col + 1, 'I')
  worksheet.write(r, col + 2, 'S')
  worksheet.write(r, col + 3, 'HS')
  r=+1
  for (t,i,s) in product(T,I,S):
      worksheet.write(r,col,t)
      worksheet.write(r,col+1,i)
      worksheet.write(r,col+2,s)
      worksheet.write(r,col+3,HS_t_i_s[(t,i,s)].x)
      r+=1

  totalharvest = 0
  for (t,i,k,s) in product(T,I,K,S):
  	totalharvest += QH_t_i_k_s[(t,i,k,s)].x
  wb.close()

  return (modelo_grupo2.getObjective(),totalharvest,tc)
  

############################################################# LECTURA ARCHIVOS DE EXCEL ######################################################################################

def main(dir_inst,dir_result):
    instancia = xlrd.open_workbook(dir_inst, ignore_workbook_corruption=True)

    #Leer indices y parametros
    #Variables independientes del modelo (Sub indices)
    T=sets_list(instancia.sheet_by_name('T'))
    K=sets_list(instancia.sheet_by_name('K'))
    I=sets_list(instancia.sheet_by_name('I'))
    V=sets_list(instancia.sheet_by_name('V'))
    #R=sets_list(instancia.sheet_by_name('R')) #El conjunto "R" estaba en las instancias, sin embargo no se usa... Lo dejamos importado de todas formas.
    S=sets_list(instancia.sheet_by_name('S'))
    
    #Parametros del modelo
    ap=param_dicc(instancia.sheet_by_name('AP'))
    eh=param_dicc(instancia.sheet_by_name('EH'))
    sh=param_dicc(instancia.sheet_by_name('SH'))
    vs=param_dicc(instancia.sheet_by_name('VS'))
    lah=param_dicc(instancia.sheet_by_name('LAH'))
    lrh=param_dicc(instancia.sheet_by_name('LRH'))
    lbh=param_dicc(instancia.sheet_by_name('LBH'))
    mop=param_dicc(instancia.sheet_by_name('MOP'))
    d=param_dicc(instancia.sheet_by_name('D'))
    p=param_dicc(instancia.sheet_by_name('P'))
    ps=param_dicc(instancia.sheet_by_name('PS'))
    ch=param_dicc(instancia.sheet_by_name('CH'))
    clabor=param_dicc(instancia.sheet_by_name('Clabor'))
    ct=param_dicc(instancia.sheet_by_name('CT'))
    cap=param_dicc(instancia.sheet_by_name('CAP'))
    Theta=param_dicc(instancia.sheet_by_name('Theta'))
	
    #Ejecutar modelo
    totalbenefit,totalharvest,tc = cosecha(dir_result,T,K,I,V,S,ap,eh,sh,vs,lah,lrh,lbh,mop,d,p,ps,ch,clabor,cap,ct,Theta)

############################################################# INICIO ######################################################################################

if __name__=="__main__":
    #DirecciÃ³n del archivo de instancia de cosecha
    dir_inst='InstanciaCosecha1replica2.xls' #/content/InstanciaCosecha1replica2.xls
    #Nombre del archivo excel de resultados
    dir_result='resultado_cosecha_gb.xlsx'
    main(dir_inst,dir_result)